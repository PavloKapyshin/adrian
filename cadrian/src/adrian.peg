%source {
    #include "utarray.h"
    #include "adrian_utils.h"
    #include "adrian_ast.h"

    char string_getc(StringIterator* string) {
        char c = StringIterator_next(string);
        if (c == 0) {
            return EOF;
        }
        return c;
    }

    #define PCC_GETCHAR(auxil) string_getc(auxil)

    UT_icd void_ptr_icd = {
        .sz = sizeof(void*), .init = NULL, .copy = NULL, .dtor = NULL
    };
}

%header {
    extern UT_array* parse(StringIterator* input_string);
}

%value "void*"
%auxil "StringIterator*"

ast <- s:statement a:ast {
        UT_array* result;
        utarray_new(result, &void_ptr_icd);
        utarray_push_back(result, s);
        utarray_concat(result, (UT_array*)a);
        utarray_free((UT_array*)a);
        $$ = result;
    }
    / "" {
        UT_array* result;
        utarray_new(result, &void_ptr_icd);
        $$ = result;
    }

statement <- d:let_declaration {
    Node* node = Node_new();
    node->let_declaration = d;
    $$ = node;
}

let_declaration <- _ "let" _ n:name _ "=" _ e:expression _ {
    Type* type = Type_new();
    type->empty = Empty_new();
    $$ = LetDeclaration_new((char*)n, type, e);
    Type_free(type);
    Expr_free(e);
}

name <- [a-zA-Z_][a-zA-Z0-9_]* {$$ = (void*)$0;}

expression <- l:literal {
    Expr* expr = Expr_new();
    expr->literal = l;
    $$ = expr;
}

literal <- n:number_literal {$$ = n;}

number_literal <- [0-9]+ {
    $$ = Literal_new(NumberLiteralType, (char*)$0);
}

_ <- [ \t\n]*


%%
UT_array* parse(StringIterator* input_string) {
    void** result;
    pcc_context_t* ctx = pcc_create(input_string);
    while (pcc_parse(ctx, result));
    pcc_destroy(ctx);
    return (UT_array*)(result[0]);
}
