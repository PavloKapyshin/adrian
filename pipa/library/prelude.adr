-- Syntax sugar is redundant! (no, it is not, but you can't use it here :)
-- Can't use:
--   for-in syntax sugar: use while loop with copying of container!
--   literal to prelude object: use something like Number(py#Int(0)) instead of 0
--   other modules (without py module): really? you need other modules in prelude module?
protocol Comparable {}

-- implement to support == and !=
protocol Eq is Comparable {
    fun __eq__(other: Self): Bool
}

-- implement to support < (and <= if Eq is implemented)
protocol Lt is Comparable {
    fun __lt__(other: Self): Bool
}

-- implement to support > (and >= if Eq is implemented)
protocol Gt is Comparable{
    fun __gt__(other: Self): Bool
}

protocol ArithmeticObject {}

-- implement to support +
protocol Addable is ArithmeticObject {
    fun __add__(other: Self): Self
}

-- implement to support -
protocol Subtractable is ArithmeticObject {
    fun __sub__(other: Self): Self
}

-- implement to support *
protocol Multipliable is ArithmeticObject {
    fun __mul__(other: Self): Self
}

-- implement to support /
protocol Divisible is ArithmeticObject {
    fun __div__(other: Self): Self
}

-- implement to support in
protocol Container(a) {
    fun __contains__(element: a): Bool
}


struct Pair(a, b) {
    first: a
    second: b

    fun __component1__(): a {
        return self.first
    }

    fun __component2__(): b {
        return self.second
    }
}

struct Triple(a, b, c) {
    first: a
    second: b
    third: c

    fun __component1__(): a {
        return self.first
    }

    fun __component2__(): b {
        return self.second
    }

    fun __component3__(): c {
        return self.third
    }
}

struct DictItemPair(a, b) {
    key: a
    value: b

    fun __component1__(): a {
        return self.key
    }

    fun __component2__(): b {
        return self.value
    }
}


protocol Maybe(a) {}

struct Some(a) is Maybe(a) {
    data: a
}

struct None is Maybe(a) {}


protocol Either(a, b) {
    data: a or b
}

struct Left(a) is Either(a, b) {
    data: a
}

struct Right(b) is Either(a, b) {
    data: b
}


fun assert(expr: Bool): Void {
    py#assert(expr)
}


struct String {
    data: py#Str
}

struct Number {
    data: py#Int
}

struct Vector(a) {
    data: py#List
}

struct Set(a) {
    data: py#Set(a)
}

struct Dict(a, b) {
    data: py#Dict(a, b)
}


protocol ConvertibleToString {
    fun __toString__(): String
}

protocol ConvertibleToNumber {
    fun __toNumber__(): Number
}

protocol ConvertibleToVector(a) {
    fun __toVector__(): Vector(a)
}

protocol ConvertibleToSet(a) {
    fun __toSet__(): Set(a)
}

protocol ConvertibleToDict(a, b) {
    fun __toDict__(): Dict(a, b)
}

fun toString(data: ConvertibleToString): String {
    return data.__toString__()
}

fun toNumber(data: ConvertibleToNumber): Number {
    return data.__toNumber__()
}

fun toVector(data: ConvertibleToVector(a)): Vector(a) {
    return data.__toVector__()
}

fun toSet(data: ConvertibleToSet(a)): Set(a) {
    return data.__toSet__()
}

fun toDict(data: ConvertibleToDict(a, b)): Dict(a, b) {
    return data.__toDict__()
}


protocol Printable {
    fun __print__(): Void
}

protocol Lengthable {
    fun __length__(): Number
}

-- implement to support for-in loop
protocol Iterator(elementType) {
    fun __next__(): Maybe(elementType)
}

protocol Iterable(elementType) {
    fun __iter__(): Iterator(elementType)
}

-- implement to support self[index]
protocol GetItemable(indexType, itemType) {
    fun __getItem__(index: indexType): Maybe(itemType)
}

-- implement to support self[index] = item
protocol SetItemable(indexType, itemType) {
    fun __setItem__(index: indexType, item: itemType): Void
}

-- implement to support self[start:end]
protocol Sliceable(indexType, resultType) {
    fun __slice__(start: indexType, end: indexType): resultType
}


fun print(data: ConvertibleToString or Printable = String(py#Str("")), end: String = String(py#Str("\n"))): Void {
    if data is Printable {
        data.__print__()
    } else {
        py#print(toString(data).data)
    }
    py#print(end.data)
}

fun length(data: Lengthable): Number {
    return data.__length__()
}

fun all(iterable: Iterable(Bool)): Bool {
    let iterator = iterable.__iter__()
    var element = iterator.__next__()
    while element is Some {
        if element.data == False {
            return False
        }
        element = iterator.__next__()
    }
    return True
}

fun any(iterable: Iterable(Bool)): Bool {
    let iterator = iterable.__iter__()
    var element = iterator.__next__()
    while element is Some {
        if element.data == True {
            return True
        }
        element = iterator.__next__()
    }
    return False
}


extension Number is ArithmeticObject, Comparable, ConvertibleToString,
                    ConvertibleToNumber {
    fun __toNumber__(): Number {
        return self
    }

    fun __toString__(): String {
        return String(py#toStr(self.data))
    }

    fun __add__(other: Number): Number {
        return Number(self.data + other.data)
    }

    fun __sub__(other: Number): Number {
        return Number(self.data - other.data)
    }

    fun __mul__(other: Number): Number {
        return Number(self.data * other.data)
    }

    fun __div__(other: Number): Number {
        return Number(self.data / other.data)
    }

    fun __eq__(other: Number): Bool {
        return self.data == other.data
    }

    fun __lt__(other: Number): Bool {
        return self.data < other.data
    }

    fun __gt__(other: Number): Bool {
        return self.data > other.data
    }
}


struct StringIterator is Iterator(String) {
    data: String
    index: py#Int

    fun __init__(data: String): Void {
        self.data = data
        self.index = py#Int(0)
    }

    fun __next__(): Maybe(String) {
        let element = self.data.data[self.index]
        if element is py#None {
            self.index = py#Int(0)
            return None()
        }
        self.index += py#Int(1)
        return Some(String(element))
    }
}

struct VectorIterator(a) is Iterator(a) {
    data: Vector(a)
    index: py#Int

    fun __init__(data: Vector(a)): Void {
        self.data = data
        self.index = py#Int(0)
    }

    fun __next__(): Maybe(a) {
        let element = self.data.data[self.index]
        if element is py#None {
            self.index = py#Int(0)
            return None()
        }
        self.index += py#Int(1)
        return Some(element)
    }
}

struct SetIterator(a) is Iterator(a) {
    data: Set(a)
    iterated: py#Set

    fun __init__(data: Set(a)): Void {
        self.data = data
        self.iterated = py#Set({})
    }

    fun __next__(): Maybe(a) {
        for element in self.data.data {
            if not (element in self.iterated) {
                self.iterated += py#Set({element})
                return Some(element)
            }
        }
        self.iterated = py#Set({})
        return None()
    }
}

struct DictIterator(a, b) is Iterator(a) {
    data: Dict(a, b)
    iterated: py#Set

    fun __init__(data: Dict(a, b)): Void {
        self.data = data
        self.iterated = py#Set({})
    }

    fun __next__(): Maybe(a) {
        for key, value in self.data.data.items() {
            if not (key in self.iterated) {
                self.iterated += py#Set({key})
                return Some(DictItemPair(key, value))
            }
        }
        self.iterated = py#Set({})
        return None()
    }
}


extension String is Addable, Container(String), Iterable(String), Lengthable,
                    Eq, GetItemable(Number, String), ConvertibleToNumber,
                    ConvertibleToVector(String), ConvertibleToSet(String),
                    Sliceable(Number, String), ConvertibleToString {
    fun __add__(other: String): String {
        return String(self.data + other.data)
    }

    fun __eq__(other: String): Bool {
        return self.data == other.data
    }

    fun __contains__(element: String): Bool {
        return element.data in self.data
    }

    fun __toNumber__(): Number {
        return Number(py#toInt(self.data))
    }

    fun __toString__(): String {
        return self
    }

    fun __toVector__(): Vector(String) {
        return Vector(py#toList(self.data))
    }

    fun __toSet__(): Set(String) {
        return Set(py#toSet(self.data))
    }

    fun __length__(): Number {
        return Number(py#len(self.data))
    }

    fun __slice__(start: Number, end: Number): String {
        return String(self.data[start.data:end.data])
    }

    fun __getItem__(index: Number): Maybe(String) {
        let got = self.data[index.data]
        if got is py#None {
            return None()
        }
        return Some(String(got))
    }

    fun __iter__(): StringIterator {
        return StringIterator(self)
    }

    fun split(by separator: String): Vector(String) {
        -- TODO: write without usage of py#Str.split
        let result: Vector(String) = Vector(py#List([]))
        for str in self.data.split(separator.data) {
            result.append(String(str))
        }
        return result
    }

    fun join(iterable: Iterable(String)): String {
        let iterator = iterable.__iter__()
        var result = py#Str("")
        var element = iterator.__next__()
        if element is Some {
            result = element.data.data
        } else {
            return String(py#Str(""))
        }
        element = iterator.__next__()
        while element is Some {
            result += self.data + element.data.data
            element = iterator.__next__()
        }
        return String(result)
    }

    fun format(changes: Dict(String, String)): String {
        -- TODO: support unpaired braces
        --       support \{...}
        let result: Vector(String) = Vector(py#List([]))
        var buffer: Vector(String) = Vector(py#List([]))
        var key: Vector(String) = Vector(py#List([]))
        var needToAppendKey: Bool = False
        for char in self.data {
            if char == py#Str("{") {
                needToAppendKey = True
                result.append(String(py#Str("")).join(buffer))
                buffer = Vector(py#List([]))
            } elif char == py#Str("}") {
                needToAppendKey = False
                let joinedKey = String(py#Str("")).join(key)
                let possibleValue = changes[joinedKey]
                if possibleValue is Some {
                    result.append(possibleValue.data)
                } else {
                    result.append(String(py#Str("{") + joinedKey.data + py#Str("}")))
                }
                key = Vector(py#List([]))
            } elif needToAppendKey {
                key.append(String(char))
            } else {
                buffer.append(String(char))
            }
        }
        result.append(String(py#Str("")).join(buffer))
        return String(py#Str("")).join(result)
    }

    fun cutBetween(start: String, end: String = String(py#Str(""))): String {
        -- TODO: support length(start) > 1
        --       support length(end) > 1
        if end.data == py#Str("") {
            end.data = start.data
        }
        var shouldRecord: Bool = False
        var buffer: py#Str = py#Str("")
        for char in self.data {
            if (char == end.data) and (shouldRecord) {
                return String(buffer)
            }
            if shouldRecord {
                buffer += char
            }
            if char == start.data {
                shouldRecord = True
            }
        }
        return String(py#Str(""))
    }

    fun count(sub: String): Number {
        -- TODO: support length(sub) > 1
        var result: py#Int = py#Int(0)
        for char in self.data {
            if char == sub.data {
                result += py#Int(1)
            }
        }
        return Number(result)
    }

    fun find(sub: String): Maybe(Number) {
        -- TODO: support length(sub) > 1
        var index: py#Int = py#Int(0)
        for char in self.data {
            if char == sub.data {
                return Some(Number(index))
            }
            index += py#Int(1)
        }
        return None()
    }

    fun isEmpty(): Bool {
        return self.data == py#Str("")
    }
}

extension Vector(a) is ConvertibleToVector(a), ConvertibleToString,
                    ConvertibleToSet(a), ConvertibleToDict(Number, a),
                    Addable, Lengthable, Iterable(a), GetItemable(Number, a),
                    SetItemable(Number, a), Eq, Container(a),
                    Sliceable(Number, Vector(a)) {
    fun __add__(other: Vector(a)): Vector(a) {
        return Vector(self.data + other.data)
    }

    fun __eq__(other: Vector(a)): Bool {
        return self.data == other.data
    }

    fun __contains__(element: a): Bool {
        return element in self.data
    }

    fun __toVector__(): Vector(a) {
        return self
    }

    fun __toString__(): String {
        let separator = py#Str(", ")
        let dataLength = length(self).data
        var index = py#Int(0)
        var result = py#Str("[")
        for element in self.data {
            if element is String {
                result += py#Str("'") + toString(element).data + py#Str("'")
            } else {
                result += toString(element).data
            }
            if index < (dataLength - py#Int(1)) {
                result += separator
            }
            index += py#Int(1)
        }
        return String(result + py#Str("]"))
    }

    fun __toSet__(): Set(a) {
        return Set(py#toSet(self.data))
    }

    fun __toDict__(): Dict(Number, a) {
        var result = Dict(py#Dict({}))
        var index = py#Int(0)
        for element in self.data {
            result[Number(index)] = element
            index += py#Int(1)
        }
        return result
    }

    fun __length__(): Number {
        return Number(py#len(self.data))
    }

    fun __slice__(start: Number, end: Number): Vector(a) {
        return Vector(self.data[start.data:end.data])
    }

    fun __getItem__(index: Number): Maybe(a) {
        let got = self.data[index.data]
        if got is py#None {
            return None()
        }
        return Some(got)
    }

    fun __setItem__(index: Number, item: a): Void {
        self.data[index.data] = item
    }

    fun __iter__(): VectorIterator(a) {
        return VectorIterator(self)
    }

    fun append(element: a): Void {
        self.data += py#List([element])
    }

    fun extend(other by: Vector(a)): Void {
        self.data += other.data
    }

    fun clear(): Void {
        self.data = py#List([])
    }

    fun isEmpty(): Bool {
        return self.data == py#List([])
    }

    fun map(transformer by: Function(a, b)): Vector(b) {
        let result: Vector(b) = Vector(py#List([]))
        for element in self.data {
            result.append(transformer(element))
        }
        return result
    }

    fun enumerated(start: Number = Number(py#Int(0))): Vector(Pair(Number, a)) {
        var result: py#List = py#List([])
        var index: py#Int = start.data
        for element in self.data {
            result += py#List([Pair(Number(index), element)])
            index += py#Int(1)
        }
        return Vector(result)
    }

    fun zipped(iterable with: Vector(b)): Vector(Pair(a, b)) {
        let iterableLength: py#Int = length(iterable).data
        var result: py#List = py#List([])
        var index: py#Int = py#Int(0)
        for element in self.data {
            if index < iterableLength {
                result += py#List([Pair(element, (iterable.data)[index])])
            } else {
                return Vector(result)
            }
            index += py#Int(1)
        }
        return Vector(result)
    }
}


extension Set(a) is Iterable(a), Addable, ConvertibleToVector(a),
                    ConvertibleToSet(a), ConvertibleToString, Eq,
                    Container(a), Lengthable, Subtractable,
                    ConvertibleToDict(a, a) {
    fun __iter__(): SetIterator(a) {
        return SetIterator(self)
    }

    fun __add__(other: Set(a)): Set(a) {
        return Set(self.data + other.data)
    }

    fun __sub__(other: Set(a)): Set(a) {
        return Set(self.data - other.data)
    }

    fun __eq__(other: Set(a)): Bool {
        return self.data == other.data
    }

    fun __contains__(element: a): Bool {
        return element in self.data
    }

    fun __length__(): Number {
        return Number(py#len(self.data))
    }

    fun __toSet__(): Set(a) {
        return self
    }

    fun __toVector__(): Vector(a) {
        return Vector(py#toList(self.data))
    }

    fun __toDict__(): Dict(a, a) {
        let result: Dict(a, a) = Dict(py#Dict({}))
        for elem in self.data {
            result[elem] = elem
        }
        return result
    }

    fun __toString__(): String {
        var elements = py#Str("")
        let len = length(self).data
        var index = py#Int(0)
        for element in self.data {
            if element is String {
                elements += py#Str("'") + element.data + py#Str("'")
            } else {
                elements += toString(element).data
            }
            if index < (len - py#Int(1)) {
                elements += py#Str(", ")
            }
            index += py#Int(1)
        }
        return String(py#Str("{") + elements + py#Str("}"))
    }

    fun add(element: a): Void {
        self.data += py#Set({element})
    }

    fun extend(other by: Set(a)): Void {
        self.data += other.data
    }

    fun isSubSet(superSet of: Set(a)): Bool {
        for element in self.data {
            if not (element in superSet.data) {
                return False
            }
        }
        return True
    }

    fun isSuperSet(subSet of: Set(a)): Bool {
        for element in subSet.data {
            if not (element in self.data) {
                return False
            }
        }
        return True
    }
}


extension Dict(a, b) is ConvertibleToDict(a, b), ConvertibleToSet(a),
                        ConvertibleToString, ConvertibleToVector(a),
                        Iterable(DictItemPair(a, b)), Addable, Eq, Container(a),
                        Lengthable, GetItemable(a, b), SetItemable(a, b) {
    fun __toDict__(): Dict(a, b) {
        return self
    }

    fun __toSet__(): Set(a) {
        return Set(py#toSet(self.data))
    }

    fun __toVector__(): Vector(a) {
        return Vector(py#toList(self.data))
    }

    fun __toString__(): String {
        var elements = py#Str("")
        var index = py#Int(0)
        let len = length(self).data
        for key, val in self.data.items() {
            if key is String {
                elements += py#Str("'") +
                    key.data + py#Str(" = ") + toString(val).data +
                py#Str("'")
            } else {
                elements += toString(key).data + py#Str(" = ") + toString(val).data
            }
            if index < (len - py#Int(1)) {
                elements += py#Str(", ")
            }
            index += py#Int(1)
        }
        return String(py#Str("{") + elements + py#Str("}"))
    }

    fun __iter__(): DictIterator(a, b) {
        return DictIterator(self)
    }

    fun __add__(other: Dict(a, b)): Dict(a, b) {
        return Dict(self.data + other.data)
    }

    fun __eq__(other: Dict(a, b)): Bool {
        return self.data == other.data
    }

    fun __contains__(element: a): Bool {
        return element in self.data
    }

    fun __length__(): Number {
        return Number(py#len(self.data))
    }

    fun __getItem__(index: a): Maybe(b) {
        let element = self.data[index]
        if element is py#None {
            return None()
        }
        return Some(element)
    }

    fun __setItem__(index: a, item: b): Void {
        self.data[index] = item
    }

    fun keys(): Vector(a) {
        return Vector(self.data.keys())
    }

    fun values(): Vector(b) {
        return Vector(self.data.values())
    }
}
