struct LexingError is ConvertibleToString {
    description: String
    lineNumber: Number

    fun __toString__(): String {
        return "LEXING ERROR (on {lineNumber}): {description}".format({
            "lineNumber" = toString(self.lineNumber),
            "description" = self.description
        })
    }
}


protocol Combinator {
    fun match(string: String): String?
}


struct UpperCaseLetter is Combinator {
    fun match(string: String): String? {
        if (length(string) == 0) or (not ((string[0])! in String(py#upperCaseLetters))) {
            return None()
        }
        return Some((string[0])!)
    }
}

struct LowerCaseLetter is Combinator {
    fun match(string: String): String? {
        if (length(string) == 0) or (not ((string[0])! in String(py#lowerCaseLetters))) {
            return None()
        }
        return Some((string[0])!)
    }
}


struct NumberCombinator is Combinator {
    fun match(string: String): String? {
        if (length(string) == 0) or (not ((string[0])! in "1234567890")) {
            return None()
        }
        return Some((string[0])!)
    }
}


struct Char is Combinator {
    char: String

    fun match(string: String): String? {
        if (length(string) == 0) or ((string[0])! != self.char) {
            return None()
        }
        return Some(self.char)
    }
}


struct AnyChar is Combinator {
    escapes: Vector(String)

    fun __init__(escapes: Vector(String) = []): Void {
        self.escapes = escapes
    }

    fun match(string: String): String? {
        let results: Vector(String) = []
        for char in string {
            if char in self.escapes {
                break
            }
            results.append(char)
        }
        if results == [] {
            return None()
        }
        return Some("".join(results))
    }
}


struct Possible is Combinator {
    combinator: Combinator

    fun match(string: String): String? {
        if let result = self.combinator.match(string) {
            return Some(result)
        }
        return Some("")
    }
}


struct OneOrMore is Combinator {
    combinator: Combinator

    fun match(string: String): String? {
        let initialLength = length(string)
        let results: Vector(String) = []
        while let result = self.combinator.match(string) {
            results.append(result)
            string = string[length(result):initialLength]
        }
        if results == [] {
            return None()
        }
        return Some("".join(results))
    }
}

struct And is Combinator {
    combinators: Vector(Combinator)

    fun match(string: String): String? {
        let initialLength = length(string)
        let results = []
        for combinator in self.combinators {
            if let result = combinator.match(string) {
                results.append(result)
                string = string[length(result):initialLength]
            } else {
                return None()
            }
        }
        if results == [] {
            return None()
        }
        return Some("".join(results))
    }
}

struct Or is Combinator {
    combinators: Vector(Combinator)

    fun match(string: String): String? {
        for combinator in self.combinators {
            if let result = combinator.match(string) {
                return Some(result)
            }
        }
        return None()
    }
}


struct Lexeme {
    text: String
    type: String

    fun __component1__(): String {
        return self.text
    }

    fun __component2__(): String {
        return self.type
    }
}


struct CombinatorLexer {
    microSyntax: Dict(Combinator, String)
    ignoreList: Vector(String)
    keywords: Vector(String)
    lineNumber: Number

    fun __init__(
            microSyntax: Dict(Combinator, String),
            ignoreList: Vector(String) = [],
            keywords: Vector(String) = []): Void {
        self.microSyntax = microSyntax
        self.ignoreList = ignoreList
        self.keywords = keywords
        self.lineNumber = 1
    }

    fun lex(input: String): Either(LexingError, Vector(Lexeme)) {
        let lexemes: Vector(Lexeme) = []
        let initialLength = length(input)
        while input != "" {
            input = self.withoutLeadingIgnorableChars(
                self.withoutLeadingNewlines(input))
            if input == "" {
                break
            }
            if let lexeme = self.getLexeme(input) {
                lexemes.append(lexeme)
                input = input[length(lexeme.text):initialLength]
            } else {
                return Left(
                    LexingError(
                        "Something is broken in lexer...", self.lineNumber))
            }
        }
        return Right(lexemes)
    }

    fun getLexeme(string: String): Lexeme? {
        for (combinator, lexemeType) in self.microSyntax {
            if let result = combinator.match(string) {
                if result in self.keywords {
                    return Some(Lexeme(result, result.upper()))
                }
                return Some(Lexeme(result, lexemeType))
            }
        }
        return None()
    }

    fun withoutLeadingNewlines(string: String): String {
        var index = 0
        for char in string {
            if char == "\n" {
                index += 1
            } else {
                self.lineNumber += index
                return string[index:length(string)]
            }
        }
        self.lineNumber += index
        return ""
    }

    fun withoutLeadingIgnorableChars(string: String): String {
        let result: Vector(String) = []
        var normalCharWasSeen = False
        for char in string {
            if (not normalCharWasSeen) and (not (char in self.ignoreList)) {
                normalCharWasSeen = True
            }
            if normalCharWasSeen {
                result.append(char)
            }
        }
        return "".join(result)
    }
}
